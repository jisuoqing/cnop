from sim_controller import update_parameter, get_system_info
import subprocess
import os
import warnings
import shlex
import yt
import numpy as np
import h5py
yt.set_log_level("error")


class Simulation:
    def __init__(self, u_init_fn: str, base_dir: str, exec_cmd: str, init_params: dict, param_fn: str, u0_fn: str,
                 pert_var: str, grow_var: str):
        """
        :param u_init_fn: Initial condition file name. If None, then the initial condition is generated by the solver
            (e.g., Flash, Athena). Otherwise, the initial condition is read from the file (e.g., Gizmo)
        :param base_dir: The directory where the simulation is run
        :param exec_cmd: The command to run the simulation
        :param init_params: Selected (cnop-related) parameters to be initialized/updated in the parameter file
        :param param_fn: The parameter file name
        :param u0_fn: The file name of the basic state, which is generated by evolving the initial condition to time t0
            (where t0 MUST be specified in init_params! This is handled by the child class)
        :param pert_var: The variable name to be perturbed
        :param grow_var: The variable name whose growth rate is aimed to be maximized
        """
        if u_init_fn is not None:
            if not os.path.exists(base_dir + "/" + u_init_fn):
                raise ValueError("The initial condition file does not exist!")
            self.u_init_fn = u_init_fn
        self.base_dir = base_dir
        self.exec_cmd = exec_cmd
        self.param_fn = param_fn
        # u0_fn is the file name of the basic state, which must match the output file name of the solver
        self.u0_fn = u0_fn
        self.pert_var = pert_var
        self.grow_var = grow_var

        if os.path.exists(self.base_dir + "/" + self.u0_fn):
            # warnings.warn("The basic state file already exists! Deleting it now for safety.")
            os.remove(self.base_dir + "/" + self.u0_fn)
        # Now evolve the initial condition to t0, to obtain u0 which is the basic state
        update_parameter(self.base_dir + "/" + self.param_fn, init_params)
        with open('%s_basic_state_stdout.txt' % self.__class__.__name__, 'w') as stdout_file, \
                open('%s_basic_state_stderr.txt' % self.__class__.__name__, 'w') as stderr_file:
            exec_args = shlex.split(self.exec_cmd)
            process = subprocess.Popen(exec_args, stdout=stdout_file, stderr=stderr_file, shell=False,
                                       cwd=self.base_dir)
            process.wait()
        if process.returncode != 0:
            raise ValueError("The solver is not working properly, and no basic state file is generated!")
        elif not os.path.exists(self.base_dir + "/" + self.u0_fn):
            raise ValueError("The basic state file might be generated, but you might guess the file name wrong!")
        # print("The basic state u0 is evolved from the initial condition u_init and saved as {}.".format(self.u0_fn))
        return

    def generate_u_pert(self, pert_mag):
        # generate a perturbation file with magnitude pert_mag
        # the perturbation file is saved as u_pert_fn
        ds = yt.load(self.base_dir + "/" + self.u0_fn)
        u_pert = np.random.uniform(-pert_mag, pert_mag, ds.domain_dimensions)
        del ds
        return u_pert

    def proceed_simulation(self, params, exec_cmd=None, u_pert=None, u_pert_fn=None, ut_fn=None, delete_fn=None):
        # evolve the basic state to time t1, with perturbation u_pert. t1 is specified in params
        # Note that only when we actually run the simulation, we need save u_pert into a file
        if exec_cmd is not None:
            # if a different command is needed for restarting
            self.exec_cmd = exec_cmd
        # Now save the perturbation into a file for the simulation to read in
        if u_pert is not None:
            if u_pert_fn is None:
                raise ValueError("The perturbation file name is not specified!")
            if os.path.exists(self.base_dir + "/" + u_pert_fn):
                # warnings.warn("The perturbation file already exists! Overwriting it.")
                os.remove(self.base_dir + "/" + u_pert_fn)
            with h5py.File(self.base_dir + "/" + u_pert_fn, 'w') as f:
                f.create_dataset('u_pert', data=u_pert)
            # Check whether the input parameter includes the perturbation file name
            if u_pert_fn not in params.values():
                raise ValueError("The perturbation file name is not included in the input parameter!")
        else:
            if u_pert_fn is not None:
                raise ValueError("The perturbation file name is specified, but the perturbation is not!")
        # Now update the parameter file
        update_parameter(self.base_dir + "/" + self.param_fn, params)
        if os.path.exists(self.base_dir + "/" + ut_fn):
            # warnings.warn("The evolving state file already exists! Deleting it now for safety.")
            os.remove(self.base_dir + "/" + ut_fn)
        # Now start the simulation
        with open('%s_evolving_state_stdout.txt' % self.__class__.__name__, 'w') as stdout_file, \
                open('%s_evolving_state_stderr.txt' % self.__class__.__name__, 'w') as stderr_file:
            exec_args = shlex.split(self.exec_cmd)
            process = subprocess.Popen(exec_args, stdout=stdout_file, stderr=stderr_file, shell=False,
                                       cwd=self.base_dir)
            process.wait()
        if process.returncode != 0:
            print("The solver is not working properly! Dump system info and retrying...")
            get_system_info()
            print("Executing command: {}".format(self.exec_cmd))
            with open('%s_evolving_state_stdout.txt' % self.__class__.__name__, 'w') as stdout_file, \
                    open('%s_evolving_state_stderr.txt' % self.__class__.__name__, 'w') as stderr_file:
                exec_args = shlex.split(self.exec_cmd)
                process = subprocess.Popen(exec_args, stdout=stdout_file, stderr=stderr_file, shell=False,
                                           cwd=self.base_dir)
                process.wait()
            if process.returncode != 0:
                raise ValueError("The solver is not working properly after a 2nd trial, and no evolving state file is "
                                 "generated!")

        if not os.path.exists(self.base_dir + "/" + ut_fn):
            raise ValueError("The evolving state file might be generated, but you might guess the file name wrong!")
        # print("The ut state is evolved from the basic state u0 and saved as {}.".format(ut_fn))

        # Delete the perturbation file
        if u_pert_fn is not None:
            os.remove(self.base_dir + "/" + u_pert_fn)

        # Delete the file specified by delete_fn for each run
        if delete_fn is not None:
            # tell delete_fn is a string or list
            if isinstance(delete_fn, str):
                delete_fn = [delete_fn]
            for fn in delete_fn:
                os.remove(self.base_dir + "/" + fn)

        # Return the evolving state ut
        ut = self.yt_read(self.base_dir, ut_fn, self.grow_var)
        return ut

    @staticmethod
    def yt_read(base_dir, fn, grow_var):
        # Return the evolving state ut as one-dimensional array, since its spatial info is not needed
        ds = yt.load(base_dir + "/" + fn)
        state = ds.all_data()[grow_var].v
        del ds
        return state
